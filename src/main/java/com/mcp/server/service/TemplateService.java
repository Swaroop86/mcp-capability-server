package com.mcp.server.service;

import freemarker.template.Configuration;
import freemarker.template.Template;
import freemarker.template.TemplateExceptionHandler;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;

import jakarta.annotation.PostConstruct;
import java.io.StringWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.UUID;

/**
 * Service for processing Freemarker templates
 * FIXED: Clear template cache between executions
 */
@Service
@Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
@Slf4j
public class TemplateService {

    private Configuration freemarkerConfig;
    private Map<String, String> inMemoryTemplates;

    @PostConstruct
    public void init() {
        // Initialize Freemarker configuration
        freemarkerConfig = new Configuration(Configuration.VERSION_2_3_32);
        freemarkerConfig.setClassForTemplateLoading(getClass(), "/templates");
        freemarkerConfig.setDefaultEncoding("UTF-8");
        freemarkerConfig.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);
        freemarkerConfig.setLogTemplateExceptions(false);
        freemarkerConfig.setWrapUncheckedExceptions(true);

        // IMPORTANT: Don't cache templates
        freemarkerConfig.setCacheStorage(new freemarker.cache.NullCacheStorage());
        freemarkerConfig.setTemplateUpdateDelayMilliseconds(0);

        // Initialize in-memory templates
        initializeTemplates();
    }

    /**
     * Process template with variables - FIXED to create fresh instances
     */
    public String processTemplate(String templateName, Map<String, Object> variables) {
        try {
            // CRITICAL: Create a deep copy of variables to avoid contamination
            Map<String, Object> cleanVariables = new HashMap<>();
            if (variables != null) {
                variables.forEach((key, value) -> {
                    if (value instanceof Map) {
                        cleanVariables.put(key, new HashMap<>((Map<?, ?>) value));
                    } else if (value instanceof List) {
                        cleanVariables.put(key, new ArrayList<>((List<?>) value));
                    } else {
                        cleanVariables.put(key, value);
                    }
                });
            }

            // Clear any cached templates
            freemarkerConfig.clearTemplateCache();

            // Use in-memory template if available
            String templateContent = inMemoryTemplates.get(templateName);
            if (templateContent != null) {
                return processInMemoryTemplate(templateContent, cleanVariables);
            }

            // Otherwise load from file system
            Template template = freemarkerConfig.getTemplate(templateName + ".ftl");
            StringWriter writer = new StringWriter();
            template.process(cleanVariables, writer);
            return writer.toString();

        } catch (Exception e) {
            log.error("Error processing template {}: ", templateName, e);
            return generateFallbackTemplate(templateName, variables);
        }
    }

    /**
     * Process in-memory template - FIXED to use fresh template instance
     */
    private String processInMemoryTemplate(String templateContent, Map<String, Object> variables) {
        try {
            // CRITICAL: Create new template instance each time
            String uniqueName = "temp_" + System.currentTimeMillis() + "_" + Thread.currentThread().getId();
            Template template = new Template(uniqueName, templateContent, freemarkerConfig);
            StringWriter writer = new StringWriter();
            template.process(variables, writer);
            return writer.toString();
        } catch (Exception e) {
            log.error("Error processing in-memory template: ", e);
            return templateContent;
        }
    }

    /**
     * Initialize in-memory templates - RECREATED each time to avoid caching
     */
    private void initializeTemplates() {
        inMemoryTemplates = new HashMap<>();

        // Entity template
        inMemoryTemplates.put("entity.java", """
            package ${packageName};
            
            import jakarta.persistence.*;
            import jakarta.validation.constraints.*;
            <#if hasLombok>
            import lombok.Data;
            import lombok.NoArgsConstructor;
            import lombok.AllArgsConstructor;
            import lombok.Builder;
            </#if>
            import java.time.LocalDateTime;
            import java.math.BigDecimal;
            import java.util.UUID;
            
            /**
             * Entity class for ${tableName} table
             * Generated by MCP Server
             */
            @Entity
            @Table(name = "${tableName}")
            <#if hasLombok>
            @Data
            @NoArgsConstructor
            @AllArgsConstructor
            @Builder
            </#if>
            public class ${className} {
                
                <#list fields as field>
                <#if field.isPrimary>
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                </#if>
                @Column(name = "${field.columnName}"<#if !field.isNullable>, nullable = false</#if><#if field.isUnique>, unique = true</#if><#if field.length??>, length = ${field.length}</#if>)
                <#if hasValidation && !field.isNullable && !field.isPrimary>
                @NotNull(message = "${field.name} is required")
                </#if>
                <#if hasValidation && field.type == "String" && field.length??>
                @Size(max = ${field.length}, message = "${field.name} must not exceed ${field.length} characters")
                </#if>
                private ${field.type} ${field.name};
                
                </#list>
                
                <#if !hasLombok>
                // Getters and Setters
                <#list fields as field>
                public ${field.type} get${field.name?cap_first}() {
                    return ${field.name};
                }
                
                public void set${field.name?cap_first}(${field.type} ${field.name}) {
                    this.${field.name} = ${field.name};
                }
                
                </#list>
                </#if>
            }
            """);

        // Repository template
        inMemoryTemplates.put("repository.java", """
            package ${packageName};
            
            import ${entityPackage}.${entityClass};
            import org.springframework.data.jpa.repository.JpaRepository;
            import org.springframework.data.jpa.repository.Query;
            import org.springframework.data.repository.query.Param;
            import org.springframework.stereotype.Repository;
            import java.util.List;
            import java.util.Optional;
            
            /**
             * Repository interface for ${entityClass}
             * Generated by MCP Server
             */
            @Repository
            public interface ${repositoryName} extends JpaRepository<${entityClass}, ${primaryKeyType}> {
                
                // Add custom query methods here
                // Example: Optional<${entityClass}> findByFieldName(String fieldName);
                
            }
            """);

        // Service template
        inMemoryTemplates.put("service.java", """
            package ${packageName};
            
            import ${entityPackage}.${entityClass};
            import ${repositoryPackage}.${repositoryClass};
            import lombok.RequiredArgsConstructor;
            import lombok.extern.slf4j.Slf4j;
            import org.springframework.stereotype.Service;
            import org.springframework.transaction.annotation.Transactional;
            import java.util.List;
            import java.util.Optional;
            
            /**
             * Service class for ${entityClass}
             * Generated by MCP Server
             */
            @Service
            @RequiredArgsConstructor
            @Transactional
            @Slf4j
            public class ${serviceName} {
                
                private final ${repositoryClass} repository;
                
                /**
                 * Create a new ${entityClass}
                 */
                public ${entityClass} create(${entityClass} entity) {
                    log.debug("Creating new ${entityClass}: {}", entity);
                    return repository.save(entity);
                }
                
                /**
                 * Find ${entityClass} by ID
                 */
                public Optional<${entityClass}> findById(${primaryKeyType} id) {
                    log.debug("Finding ${entityClass} by id: {}", id);
                    return repository.findById(id);
                }
                
                /**
                 * Find all ${entityClass} entities
                 */
                public List<${entityClass}> findAll() {
                    log.debug("Finding all ${entityClass} entities");
                    return repository.findAll();
                }
                
                /**
                 * Update existing ${entityClass}
                 */
                public ${entityClass} update(${primaryKeyType} id, ${entityClass} entity) {
                    log.debug("Updating ${entityClass} with id: {}", id);
                    // Set the ID to ensure update
                    // entity.setId(id); // Uncomment and adjust based on your entity
                    return repository.save(entity);
                }
                
                /**
                 * Delete ${entityClass} by ID
                 */
                public void deleteById(${primaryKeyType} id) {
                    log.debug("Deleting ${entityClass} with id: {}", id);
                    repository.deleteById(id);
                }
                
                /**
                 * Check if ${entityClass} exists by ID
                 */
                public boolean existsById(${primaryKeyType} id) {
                    return repository.existsById(id);
                }
                
                /**
                 * Count all ${entityClass} entities
                 */
                public long count() {
                    return repository.count();
                }
            }
            """);

        // Controller template
        inMemoryTemplates.put("controller.java", """
            package ${packageName};
            
            import ${entityPackage}.${entityClass};
            import ${servicePackage}.${serviceClass};
            import lombok.RequiredArgsConstructor;
            import lombok.extern.slf4j.Slf4j;
            import org.springframework.http.HttpStatus;
            import org.springframework.http.ResponseEntity;
            import org.springframework.web.bind.annotation.*;
            import jakarta.validation.Valid;
            import java.util.List;
            
            /**
             * REST Controller for ${entityClass}
             * Generated by MCP Server
             */
            @RestController
            @RequestMapping("${apiPath}")
            @RequiredArgsConstructor
            @Slf4j
            @CrossOrigin(origins = "*")
            public class ${controllerName} {
                
                private final ${serviceClass} service;
                
                /**
                 * Create a new ${entityClass}
                 */
                @PostMapping
                public ResponseEntity<${entityClass}> create(@Valid @RequestBody ${entityClass} entity) {
                    log.info("Creating new ${entityClass}");
                    ${entityClass} created = service.create(entity);
                    return new ResponseEntity<>(created, HttpStatus.CREATED);
                }
                
                /**
                 * Get ${entityClass} by ID
                 */
                @GetMapping("/{id}")
                public ResponseEntity<${entityClass}> getById(@PathVariable ${primaryKeyType} id) {
                    log.info("Getting ${entityClass} by id: {}", id);
                    return service.findById(id)
                        .map(ResponseEntity::ok)
                        .orElse(ResponseEntity.notFound().build());
                }
                
                /**
                 * Get all ${entityClass} entities
                 */
                @GetMapping
                public ResponseEntity<List<${entityClass}>> getAll() {
                    log.info("Getting all ${entityClass} entities");
                    List<${entityClass}> entities = service.findAll();
                    return ResponseEntity.ok(entities);
                }
                
                /**
                 * Update existing ${entityClass}
                 */
                @PutMapping("/{id}")
                public ResponseEntity<${entityClass}> update(
                        @PathVariable ${primaryKeyType} id, 
                        @Valid @RequestBody ${entityClass} entity) {
                    log.info("Updating ${entityClass} with id: {}", id);
                    if (!service.existsById(id)) {
                        return ResponseEntity.notFound().build();
                    }
                    ${entityClass} updated = service.update(id, entity);
                    return ResponseEntity.ok(updated);
                }
                
                /**
                 * Delete ${entityClass} by ID
                 */
                @DeleteMapping("/{id}")
                public ResponseEntity<Void> delete(@PathVariable ${primaryKeyType} id) {
                    log.info("Deleting ${entityClass} with id: {}", id);
                    if (!service.existsById(id)) {
                        return ResponseEntity.notFound().build();
                    }
                    service.deleteById(id);
                    return ResponseEntity.noContent().build();
                }
            }
            """);
    }

    /**
     * Generate fallback template
     */
    private String generateFallbackTemplate(String templateName, Map<String, Object> variables) {
        if (templateName.contains("entity")) {
            return generateBasicEntity(variables);
        } else if (templateName.contains("repository")) {
            return generateBasicRepository(variables);
        } else if (templateName.contains("service")) {
            return generateBasicService(variables);
        } else if (templateName.contains("controller")) {
            return generateBasicController(variables);
        }
        return "// Generated file for " + templateName;
    }

    private String generateBasicEntity(Map<String, Object> variables) {
        return String.format("""
            package %s;
            
            import jakarta.persistence.*;
            
            @Entity
            @Table(name = "%s")
            public class %s {
                @Id
                @GeneratedValue(strategy = GenerationType.IDENTITY)
                private Long id;
                
                // Add fields here
            }
            """,
                variables.get("packageName"),
                variables.get("tableName"),
                variables.get("className")
        );
    }

    private String generateBasicRepository(Map<String, Object> variables) {
        return String.format("""
            package %s;
            
            import org.springframework.data.jpa.repository.JpaRepository;
            import org.springframework.stereotype.Repository;
            
            @Repository
            public interface %s extends JpaRepository<%s, Long> {
            }
            """,
                variables.get("packageName"),
                variables.get("repositoryName"),
                variables.get("entityClass")
        );
    }

    private String generateBasicService(Map<String, Object> variables) {
        return String.format("""
            package %s;
            
            import org.springframework.stereotype.Service;
            import org.springframework.transaction.annotation.Transactional;
            
            @Service
            @Transactional
            public class %s {
                // Add service methods here
            }
            """,
                variables.get("packageName"),
                variables.get("serviceName")
        );
    }

    private String generateBasicController(Map<String, Object> variables) {
        return String.format("""
            package %s;
            
            import org.springframework.web.bind.annotation.*;
            
            @RestController
            @RequestMapping("%s")
            public class %s {
                // Add controller methods here
            }
            """,
                variables.get("packageName"),
                variables.get("apiPath"),
                variables.get("controllerName")
        );
    }

    /**
     * Clear all template caches
     */
    public void clearCache() {
        freemarkerConfig.clearTemplateCache();
        initializeTemplates(); // Reinitialize templates
        log.info("Template cache cleared");
    }
}